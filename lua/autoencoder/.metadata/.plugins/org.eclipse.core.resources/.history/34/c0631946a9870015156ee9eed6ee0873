require 'unsup';
require 'nn';
require 'gnuplot';
require 'Encoder';
require 'nngraph';
require 'image';
require 'optim';
require 'LoadData'

--load Data
testdata,traindata = loadData{normalizeMean = false} 

n_hidden = 50
n_input = 32*32

--initialize Encode
enc = nn.Encoder(1,50,7)

--initialize Decoder
dec = nn.ParallelTable()
declin1 = nn.SpatialConvolution(50, 1, 7, 7)
declin2 = nn.SpatialConvolution(50,1, 7, 7)

decConv1 = nn.Sequential()
decConv1:add(nn.SpatialZeroPadding(3,3,3,3))
decConv1:add(declin1)

decConv2 = nn.Sequential()
decConv2:add(nn.SpatialZeroPadding(3,3,3,3))
decConv2:add(declin2)

declin1:share(declin2,'weight')
declin1:share(declin2,'gradWeight')
declin1.bias = torch.Tensor(1):zero()
declin1.gradBias = torch.Tensor(1):zero() 
declin2.bias = torch.Tensor(1):zero()
declin2.gradBias = torch.Tensor(1):zero() 

dec:add(decConv1)
dec:add(decConv2)


autoencoder = nn.Sequential()
autoencoder:add(enc)
autoencoder:add(dec)

--set Criterion 
criterion = nn.ParallelCriterion()

xcrit = nn.MSECriterion() --compare x_in and x_out
ycrit = nn.MSECriterion() --compare y_in and y_out

criterion:add(xcrit,0.5)
criterion:add(ycrit,0.5)

parameters, gradParameters = autoencoder:getParameters()
batchsize = 128
config = {learningRate = 0.01,
         weightDecay = 5e-5,
         momentum = 0,
         learningRateDecay = 5e-7}
for i = 1,3000,batchsize do
    
    local feval = function(x)
        if x ~= parameters then
            parameters:copy(x)
        end

        -- reset gradients
        gradParameters:zero()
        local f = 0 
        for j = 0,batchsize-1 do            
            local activity = traindata[i+j]
           -- local phase = torch.Tensor(1,32,32):zero()
            local phase = (torch.rand(1,32,32)*2*math.pi)-math.pi
            local input = {torch.cmul(activity,torch.cos(phase)),torch.cmul(activity,torch.sin(phase)) }
            for k = 1,30 do
                input = {input[1],autoencoder:forward(input)[2]}
            end
            local target = input
            local output = autoencoder:forward(input)
            local err = criterion:forward(output,target) 
            local df_dw = criterion:backward(autoencoder.output,target)
            f = f+err
            autoencoder:backward(input,df_dw)
        end
        gradParameters:div(batchsize)
        f = f/batchsize
        return f, gradParameters
    end 
    
    optim.sgd(feval, parameters, config)

    
    declin1.bias = torch.Tensor(1):zero()
    declin1.gradBias = torch.Tensor(1):zero()
    declin2.bias = torch.Tensor(1):zero()
    declin2.gradBias = torch.Tensor(1):zero()
    enc.convBias = torch.Tensor(50):zero()
    enc.convGradBias = torch.Tensor(50):zero()

end 
activity = traindata[9001]
phases = torch.Tensor(10,32,32)
images = torch.Tensor(10,3,32,32)
itorch.image(activity)

for i = 1,10 do
        
    local phase = (torch.rand(1,32,32)*2*math.pi)---math.pi
    local inp = {torch.cmul(activity,torch.cos(phase)),torch.cmul(activity,torch.sin(phase))}

    local out = autoencoder:forward(inp)
    local phase_out = torch.atan2(out[2],out[1])
    
    for j = 1,100 do
        out = autoencoder:forward({torch.cmul(activity,torch.cos(phase_out)),torch.cmul(activity,torch.sin(phase_out))})
        phase_out = torch.atan2(out[2],out[1])
    end
    
    a_out = torch.sqrt( torch.pow(out[1],2) + torch.pow(out[2],2 ))


    hsv = torch.Tensor(3,32,32)
    hsv[1]:copy((phase_out+math.pi)/(2*math.pi))
    hsv[2] = torch.Tensor(32,32):fill(0.5)
    hsv[3] = torch.Tensor(32,32):fill(0.5)
    rgb = image.hsv2rgb(hsv)

    phases[i] = phase_out[1]
    itorch.image(rgb)
    images[i] = rgb

    
    
end

local phase_diff  = torch.Tensor(5,32,32)
local j = 1
for i = 1,9,2 do
    phase_diff[j] = phases[i]-phases[i+1]
    phase_diff[j] = phase_diff[j] - (torch.floor(phase_diff[j]/(2*math.pi))*(2*math.pi))
    j = j+1

end

gnuplot.hist(phase_diff,100)
itorch.image(a_out)
image.save('5000TrainNoPhase.png',images[2])
    local activity = traindata[9001]
    local phase = torch.Tensor(1,32,32):zero()
    local inp = {torch.cmul(activity,torch.cos(phase)),torch.cmul(activity,torch.sin(phase))}

    local out = autoencoder:forward(inp)

    local a = torch.sqrt( torch.pow(out[1],2) + torch.pow(out[2],2 ))
    local phase_out = torch.atan2(out[2],out[1])
    itorch.image(a)
--print(enc.encoder:get(1):get(1):get(1):get(1):get(2).weight)
print(autoencoder:get(2):get(1):get(2).weight)
print(a:get(2):get(1):get(2).weight)
print(gradParameters)
itorch.image(image.load('5000TrainNoPhase.png'))



